//##################################### noises.lib ########################################
// A library of noise generators.
//
// It should be used using the `no` environment:
//
// ```
// no = library("noises.lib");
// process = no.functionCall;
// ```
//
// Another option is to import `stdfaust.lib` which already contains the `no`
// environment:
//
// ```
// import("stdfaust.lib");
// process = no.functionCall;
// ```
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Except where noted otherwise, Copyright (C) 2003-2016 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
no(x) = x; // so functions in this file can use the 'no' prefix
           // (for compatible copy/paste out of this file)

declare name "Faust Noise Generator Library";
declare version "0.0";

//=============================Functions Reference========================================
//========================================================================================

//-------`noise`----------
// White noise generator (outputs random number between -1 and 1).
// `Noise` is a standard Faust function.
//
// #### Usage
//
// ```
// noise : _
// ```
//------------------------
noise = random / RANDMAX
with{
	mask = 4294967295; // 2^32-1
	random = +(12345) ~ *(1103515245) & mask; // "linear congruential"
	RANDMAX	= 2147483647.0; // = 2^31-1 = MAX_SIGNED_INT in 32 bits
};

//---------------------`multirandom`--------------------------
// Generates multiple decorrelated random numbers
// in parallel.
//
// #### Usage
// ```
// multirandom(n) : _
// ```
//
// Where:
//
// * `n`: the number of decorrelated random numbers in parallel
//-------------------------------------------------------------
multirandom(n) = randomize(n) ~_
with {
	randomize (1) 	= +(12345) : *(1103515245);
	randomize (n) 	= randomize(1) <: randomize(n-1),_;
};

//-----------------------`multinoise`------------------------
// Generates multiple decorrelated noises
// in parallel.
//
// #### Usage
//
// ```
// multinoise(n) : _
// ```
//
// Where:
//
// * `n`: the number of decorrelated random numbers in parallel
//------------------------------------------------------------
multinoise(n) = multirandom(n) : par(i,n,/(RANDMAX))
with {
	RANDMAX = 2147483647.0;
};


//-----------------------`noises`------------------------
// TODO.
//----------------------------------------------------------
noises(N,i) = multinoise(N) : ba.selector(i,N);


//---------------------------`pink_noise`--------------------------
// Pink noise (1/f noise) generator (third-order approximation)
// `pink_noise` is a standard Faust function.
//
// #### Usage
//
// ```
// pink_noise : _;
// ```
//
// #### Reference:
//
// <https://ccrma.stanford.edu/~jos/sasp/Example_Synthesis_1_F_Noise.html>
//
// #### License
// * Copyright (C) 2010-2017 by [jos](http://ccrma.stanford.edu/~jos/)
// * License: [STK-4.3](stk4p3-license.md)
// * Markdown by [rrm](http://ccrma.stanford.edu/~rmichon/)
//------------------------------------------------------------
pink_filter = fi.iir((0.049922035, -0.095993537, 0.050612699, -0.004408786),
                    (-2.494956002, 2.017265875, -0.522189400));

pink_noise = noise : pink_filter;

//-------------------------`pink_noise_vm`-------------------
// Multi pink noise generator.
//
// #### Usage
//
// ```
// pink_noise_vm(N) : _;
// ```
//
// Where:
//
// * `N`: number of latched white-noise processes to sum,
// 	not to exceed sizeof(int) in C++ (typically 32).
//
// #### References
//
// * <http://www.dsprelated.com/showarticle/908.php>
// * <http://www.firstpr.com.au/dsp/pink-noise/#Voss-McCartney>
//
// #### License
// * Copyright (C) 2016-2017 by [jos](http://ccrma.stanford.edu/~jos/)
// * License: [STK-4.3](stk4p3-license.md)
// * Markdown by [rrm](http://ccrma.stanford.edu/~rmichon/)
//------------------------------------------------------------
pink_noise_vm(N) = noise <: _,par(i,N,ba.latch(clock(i))) :> _
with {
  clock(i) = (ba.time>>i)&1; // i'th latch clock signal
};

//-----------------------`lfnoise`, `lfnoise0` and `lfnoiseN`---------------------
// Low-frequency noise generators (Butterworth-filtered downsampled white noise)
//
// #### Usage
//
// ```
// lfnoise0(rate) : _;   // new random number every int(SR/rate) samples or so
// lfnoiseN(N,rate) : _; // same as "lfnoise0(rate) : lowpass(N,rate)" [see filters.lib]
// lfnoise(rate) : _;    // same as "lfnoise0(rate) : seq(i,5,lowpass(N,rate))" (no overshoot)
// ```
//
// #### Example
//
// (view waveforms in faust2octave):
//
// ```
// rate = SR/100.0; // new random value every 100 samples (SR from music.lib)
// process = lfnoise0(rate),   // sampled/held noise (piecewise constant)
//           lfnoiseN(3,rate), // lfnoise0 smoothed by 3rd order Butterworth LPF
//           lfnoise(rate);    // lfnoise0 smoothed with no overshoot
// ```
//
// #### License
// * Copyright (C) 2013-2017 by [jos](http://ccrma.stanford.edu/~jos/)
// * License: [STK-4.3](stk4p3-license.md)
// * Markdown by [rrm](http://ccrma.stanford.edu/~rmichon/)
//------------------------------------------------------------
lfnoise0(freq) = noise : ba.latch(os.oscrs(freq));
lfnoiseN(N,freq) = lfnoise0(freq) : fi.lowpass(N,freq); // Nth-order Butterworth lowpass
lfnoise(freq) = lfnoise0(freq) : seq(i,5,fi.lowpass(1,freq)); // non-overshooting lowpass

//-------------------------`velvet_noise_vm`-------------------
// velvet noise generator.
//
// #### Usage
//
// ```
// velvet_noise(amp,f0) : _;
// ```
//
// Where:
//
// * `amp`: amplitude of noise impulses (positive and negative)
// * ` f0`: average frequency of noise impulses per second
//
// #### Reference
//
// * Matti Karjalainen and Hanna Järvelä̈inen,
//   "Reverberation Modeling Using Velvet Noise",
//   in Proc. 30th Int. Conf. Intelligent Audio Environments (AES07),
//   March 2007.
//
// #### License
// * Copyright (C) 2017 by [jos](http://ccrma.stanford.edu/~jos/)
// * License: [STK-4.3](stk4p3-license.md)
// * Markdown by [rrm](http://ccrma.stanford.edu/~rmichon/)
//------------------------------------------------------------
velvet_noise(amp,f0) = vn
with {
  saw = os.lf_sawpos(f0);
  sawdiff = saw - saw';
  e = no.noise;
  noiseHeld = e : ba.latch(sawdiff);
  noiseHeldPos = 0.5 + 0.5 * noiseHeld;
  crossed = (saw >= noiseHeldPos) * (saw' < noiseHeldPos);
  signedamp = select2(e>0, -amp, amp);
  vn = signedamp * crossed;
};
